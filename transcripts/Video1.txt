1
CHRIST (Deemed to be University) Online Degree Programmes
Programme: M.Sc. DS
Course: Python Programming
Unit: 2
Topic: Sequence Data Types: Strings & Tuples
Faculty: Dr Tulasi.B
Hello everyone, and welcome to Module 2 of the course!
In this video, we will begin exploring a fundamental concept in Python sequence data types,
which are central to how data is organized and manipulated in programming. Our focus today
will be on the most widely used and versatile sequence types: strings and tuples. Strings
represent sequences of characters and play a vital role in data science workflows, especially
when working with text data, parsing logs, and even building models for Natural Language
Processing (NLP).
Though strings might seem simple, they support a wide range of operations like slicing,
searching, and formatting, making them a powerful tool in your programming toolkit. Tuples
are ordered collections in Python, quite similar to lists. In the next few minutes, we will build
an understanding of what makes sequence types unique, how they behave in Python, and why
they are foundational for any data-driven application. So let’s get started.
To better understand sequence data types and how they operate, let’s look at two simple yet
powerful real-world analogies. The first one is a DNA sequence. We know that DNA is made
up of a specific order of nucleotides: A, T, G, and C. The order of these characters determines
genetic traits. Each base in the sequence can be accessed by its position for example, the
third nucleotide or a slice from position 5 to 10. This is a natural example of a biological
string where indexing and order are critical.
The second example is a recipe. Every recipe has a clear, step-by-step progression, from
preparing ingredients to cooking and serving. If the steps are rearranged or skipped, the result
is affected. This is exactly how sequence types behave in Python: the position of each item
carries meaning, and rearranging them impacts the result. So whether it’s DNA or steps in a
cooking process, the core idea of a sequence is an ordered collection where position matters.
It is foundational not just in Python, but in many domains.
Technically, in Python, a sequence is any ordered set of elements. Each element can be
accessed using an index, and the entire sequence is iterable, meaning you can loop through it
element by element. These properties order, index-based access, and iterability make
sequence data types essential for working with structured and semi-structured data.
Python’s core built-in sequence types are strings, lists, tuples, and range objects. Strings
represent sequences of Unicode characters, ideal for text processing and data parsing. They
are immutable, meaning once defined they cannot be changed. Lists are ordered collections
that are mutable, so you can add, remove, or change elements. Tuples are similar to lists but
2
CHRIST (Deemed to be University) Online Degree Programmes
immutable, making them perfect for storing fixed data like coordinates or RGB values. Range
objects represent sequences of numbers and are often used for iteration.
Strings are sequences of characters. You can create them using single or double quotes
Python treats both the same. Triple quotes are used for multi-line strings.
To access individual characters, we use indexing. Indexing starts at 0 for the first character.
For example, in "Python", index 0 is 'P', index 1 is 'y', and index 5 is 'n'.
Negative indexing allows access from the end of the string, with -1 as the last character, -2 as
the second last, and so on. This is very useful when you don’t know the length but need
elements from the end, such as file extensions.
We can also extract portions of a string using slicing: [start:stop:step]. Start is where the slice
begins, stop is where it ends (not including the character at that index), and step determines
the increment. Omitting start defaults to the beginning, omitting stop goes to the end, and
omitting step defaults to 1.
For example, on the string “Python”:
• string[1:5:2] starts at index 1 ('y'), stops before index 5 ('n'), and takes every 2nd
character → 'yh' is skipped because step would pick 'y' and 'o'.
• Using [::-1] reverses the string. Omitting start and stop considers the whole string, and
step -1 iterates backwards.
Python supports arithmetic-like operations on strings. The concatenation operator + joins
strings end-to-end, and the repetition operator * repeats a string a given number of times.
Strings can also be compared using operators like ==, !=, >, <, >=, and <=. Python compares
them lexicographically, character by character, based on Unicode values. The comparison
stops at the first difference.
Sometimes we need to include special characters in strings, such as quotes. We use escape
sequences starting with a backslash \. For example, \' allows a single quote inside a singlequoted string. Special sequences like \n (newline) and \t (tab) are common for formatting.
Strings have many built-in methods. Since strings are immutable, these methods return new
strings without altering the original. .upper() converts all characters to uppercase, .lower() to
lowercase. .strip() removes leading and trailing whitespace. .replace(old, new) replaces all
occurrences of a substring.
The .find(substring) method finds the first occurrence of the substring and returns its index,
or -1 if not found. .startswith(prefix) returns True if the string begins with the given
prefix. .endswith(suffix) returns True if it ends with the given suffix.
For breaking strings apart, .split(separator) returns a list of substrings split wherever the
separator appears. Without a separator, it splits on whitespace. For
joining, .join(iterable) concatenates elements of an iterable into a single string, using the
string before .join() as the separator.
Let’s apply some of these methods in a simple program: a user input cleaning tool. The
program asks for the user’s full name, a short message, and a keyword. We:
• Strip extra spaces and convert the name to title case.
• Strip spaces from the message.
3
CHRIST (Deemed to be University) Online Degree Programmes
• Perform a case-insensitive search of the keyword in the message using .lower() and
the in keyword.
• Count words in the message by splitting and using len().
• Replace any occurrence of “Python” with “PYTHON”.
Finally, we print a neatly formatted summary of the cleaned and processed inputs.
Now let’s move on to another sequence data type the tuple. Tuples are very similar to lists:
ordered collections where each item has a position and can be accessed by index. The key
difference is that tuples are immutable once created, their contents cannot be altered. This
makes them ideal for data that should remain constant, such as coordinates, RGB colors, or
date values.
We create tuples by placing elements in parentheses, separated by commas. Tuples can hold
mixed data types and can be accessed just like strings and lists.
Because they are ordered, tuples support indexing, slicing, and iteration. They have two builtin methods: .count(value) which tells you how many times a value appears,
and .index(value) which returns the position of the first occurrence of that value.
With these examples and our program, we see that sequences are vitally important for
working with data in Python. They are the building blocks for handling and processing many
kinds of data formats.
Thank you for your attention. Keep practising and exploring! I look forward to the next
session with you.





Hello everyone!
In this session, we are diving into one of the most powerful built-in data types in
Python Dictionaries.
Dictionaries allow us to store and manage data using a key-value structure. This is incredibly
useful in real-world situations like lookup tables, user profiles, and configuration settings.
Think of them as a way to store information using labels instead of positions much like how
we use words to find meanings in a dictionary, rather than memorising page numbers.
A Python dictionary stores data as key-value pairs. Each key is a unique identifier and maps
to a corresponding value.
A real-life example could be a student ID card:
• Name: “Ananya” — here “Name” is the key, and “Ananya” is the value
• ID: “21DS045” — key is “ID”, value is “21DS045”
• Dept: “Data Science” — key is “Dept”, value is “Data Science”
Unlike lists or tuples, where the order matters for accessing elements, dictionaries are
unordered collections. Even though Python 3.7+ maintains insertion order, it’s best to think
of them as structures where retrieval is always done by keys.
We create dictionaries using curly braces {} with key-value pairs separated by colons, and
pairs separated by commas. Keys must be immutable types such as strings, numbers, or
tuples.
For example:
student = {
 "Name": "Ananya",
 "ID": "21DS045",
 "Dept": "Data Science"
}
To access a value, use square brackets with the key:
student["Name"]
2
CHRIST (Deemed to be University) Online Degree Programmes
If the key doesn’t exist, Python will raise a KeyError.
To add a new key-value pair, assign a value to a new key:
student["Email"] = "ananya@example.com"
To modify an existing value, use the same syntax if the key already exists, the value will be
updated:
student["Email"] = "ananya.ds@example.com"
The .get() method provides a safer way to access values. If the key doesn’t exist, it
returns None or a default value you specify, instead of raising a KeyError.
For example:
python
student.get("City", "Not Found")
We can remove elements from a dictionary in several ways. Using del, we can delete a
specific key-value pair:
del student["Email"]
If the key doesn’t exist, this will raise an error.
The .pop() method removes the key-value pair and returns the value. We can also provide a
default value to avoid errors if the key isn’t found:
student.pop("Email", "Not Available")
The .popitem() method removes and returns the most recently inserted key-value pair as a
tuple. From Python 3.7 onwards, it will always remove the last inserted item.
The .clear() method removes all items from a dictionary, leaving it empty.
Dictionaries also offer ways to retrieve different views of their contents:
• .keys() returns all keys in the dictionary
• .values() returns all values
• .items() returns all key-value pairs as tuples
These views are dynamic, meaning changes to the dictionary are automatically reflected in
them.
Let’s put these concepts into practice with a bookstore inventory example. We’ll use a
dictionary where book titles are keys and the number of copies in stock are values.
We start by creating the initial inventory:
inventory = {
 "The Lord of the Rings": 5,
 "Pride and Prejudice": 3
}
Next, we add a new book:
3
CHRIST (Deemed to be University) Online Degree Programmes
inventory["1984"] = 4
We can increase the stock of an existing book:
inventory["Pride and Prejudice"] += 2
To check stock for a book, we use:
inventory["The Lord of the Rings"]
If we want to check for a non-existent book without errors, we use .get():
inventory.get("Harry Potter", "Not Available")
To remove a book, we can use .pop():
inventory.pop("1984")
When selling a book, we check that stock is available before decreasing the count:
if inventory["Pride and Prejudice"] > 0:
 inventory["Pride and Prejudice"] -= 1
To handle books not in stock gracefully, we use:
copies = inventory.get("The Hobbit", 0)
We can retrieve all book titles, stock counts, and book-stock pairs:
list(inventory.keys())
list(inventory.values())
list(inventory.items())
Finally, to clear the entire inventory, we use:
inventory.clear()
In this session, we explored what dictionaries are, how to create them, and how to add,
modify, access, and remove their contents. We also saw practical dictionary methods in
action and applied them to manage a bookstore inventory. Dictionaries are one of Python’s
most efficient tools for working with key-value data, making data handling quick, clear, and
reliable.
Keep coding, keep experimenting and I’ll see you in the next session.




V3
Welcome all! Let us continue our understanding of dictionaries. We had earlier explored the
fundamental concepts about dictionaries, and in this video, we will look into a powerful and
elegant way to create dictionaries in Python using concise, readable syntax called dictionary
comprehension.
Dictionary comprehensions are a quick way to construct dictionaries using a single line of
code. If you are familiar with list comprehensions, you will find the underlying principle
similar. This feature enables a more streamlined and often more efficient approach to
dictionary creation.
The structure of a dictionary comprehension begins with curly braces {}, just like a regular
dictionary. Inside, we first define how the key will be generated for each item, followed by a
colon : , and then how the corresponding value will be created. This key–value pair
generation is linked to a for loop that iterates through each item in our iterable which could
be a list, tuple, or any sequence of elements. The item from this loop is then used in the key
expression and the value expression to construct the dictionary. For example, for each
number in a list, you can set the number as the key and its square as the value.
If we compare this with the traditional approach, normally we might use a loop to populate a
dictionary step by step, but the dictionary comprehension achieves the same result in a single
line more readable and compact.
We can also add conditional logic to dictionary comprehensions. An optional if condition can
be placed at the end of the comprehension. This condition acts like a filter: as we iterate
through each item in our iterable, it is evaluated, and only if the condition is true for a
particular item will that item be processed further to create a key–value pair in the resulting
dictionary. If the condition is false, the item is skipped. For example, iterating through
numbers from 0 to 9, we can check if each number is even. Only even numbers would then be
included as keys, with their squares as values, effectively filtering out odd numbers.Dictionary comprehensions are also useful when working with existing dictionaries. Calling
the items() method on a dictionary returns key–value tuple pairs. In a dictionary
comprehension, you can unpack these pairs into separate variables and transform them as
needed. For example, you might keep the item name from the original dictionary as the key
but reduce its price by 10% for the value. It’s also possible to include conditions so only
certain items get discounted. This approach lets us restructure or transform dictionary data
much more concisely than with a traditional for loop.Another common scenario is when we have two separate lists one containing keys, the other
containing values and we want to combine them into a dictionary. Python’s zip() function
pairs elements from both lists position by position. We can then loop through each pair in a
dictionary comprehension, assigning the first element as the key and the second as the value.
This approach is crisp and keeps the code clean and readable, especially when working with
paired data.
We can even create nested dictionary comprehensions to build multi-level or structured data.
For example, suppose we have a list of students and a list of subjects. We can create a
dictionary where each student is a key, and the value is another dictionary with subjects as
keys and randomly generated marks as values. The outer comprehension loops through each
student, and the inner comprehension loops through each subject for that student. This
produces a neat, readable, nested dictionary structure, perfect for academic data, performance
reports, or grouped information.
While dictionary comprehensions are powerful, it’s important to know when to use them and
when to stick to traditional loops. They are ideal when generating a new dictionary from an
existing iterable with relatively simple transformations or filters. They improve code clarity
in these situations. However, if the logic becomes too complex and the comprehension hard
to read, a regular loop is better for readability and maintainability. If you require very finegrained control over iteration or need to optimize performance in intricate situations, a
traditional loop might be the better choice.
Let’s look at an exercise. Suppose we have a list of words, and we want to use a dictionary
comprehension to generate a new dictionary that only contains words longer than four
characters. For these words, the key should be the uppercase version of the word, and the
value should be the length of the original word. For example, given the list ['apple', 'banana',
'kiwi', 'orange', 'grape', 'fig'], the condition filters out words of four characters or fewer. Each qualifying word is converted to uppercase for the key, and its length is the value. The final
dictionary would include only Apple, Banana, Orange, and Grape as keys, with their
respective lengths as values.
Now for a second exercise: we have two lists, one with names and another with salaries, and
we want to create a dictionary mapping each name to their salary, but only including entries
where the salary is strictly greater than fifty thousand. Using zip(), we pair each name with its
corresponding salary. Then, in the dictionary comprehension, we filter these pairs so that only
those with salaries above fifty thousand are included. For example, with
names Anitha, Bhavana, Chandan, and Damodar, only Anitha, Chandan, and Damodar make
it into the final dictionary because their salaries meet the condition.
In essence, dictionary comprehensions are a neat and very Pythonic way to build dictionaries.
They let you write code that is both concise and easy to understand. For many everyday tasks
involving dictionary creation, they produce cleaner, simpler code compared to writing out full
loops. The best way to master them is by using them in your own projects with practice,
you’ll gain comfort and skill with this powerful tool in your Python programming toolkit.
Thank you for your participation. Please continue to develop your coding skills and pursue
further learning. I’ll see you in the next video.

V4

Hello everyone, and welcome to this session!
Today, we will explore an essential data structure in Python the set. In programming, sets are
crucial because they allow us to store unique elements efficiently and perform mathematical
operations on them. In this video, we will understand how to use sets, their key properties,
and their application in Python projects. Let’s begin!
To better understand what a set is and how it operates, think of a basket where you’re
collecting fruits, and you only care about the unique types of fruits in the basket, not the
quantity. If you add apples, bananas, and oranges, but put an apple in again, it won’t be
counted twice because you are only storing unique types. For example, if the basket initially
contains Apple, Banana, Apple, Orange, in a set it would be Apple, Banana, Orange.
This highlights two important characteristics of sets: no duplicates even though you added
“apple” twice, it only appears once and unordered the fruit types don’t need to be stored in
the order you added them. Technically, in Python, a set is an unordered collection of unique
elements. Unlike sequences such as strings or lists, sets do not allow duplicates and they
don’t maintain order.
Sets are mutable, so you can add or remove elements after creating them, but the elements
themselves must be immutable types like strings or tuples. Sets do not support indexing, so
you can’t access elements by position.
You can create a set using curly braces {} or the set() method. Both give us a set, but to
create an empty set you must use the set() constructor using {} would create an empty
dictionary instead. For example, my_set = {1, 2, 3} creates a set with three elements,
and empty_set = set() creates an empty set.
Once a set is created, we can add elements using the .add() method. This adds a single
element, but if the element already exists, the set remains unchanged. For instance, adding 4
to a set will update it, but trying to add 2 again (when it already exists) has no effect.
To remove elements, we can use remove() or discard(). The remove() method deletes the
specified element but raises a KeyError if the element doesn’t exist. In contrast, discard() also
removes an element but does nothing if it’s absent no error is raised.
Sets in Python also support powerful mathematical operations. The union of two sets contains
all unique elements from both sets. You can use the pipe operator | or the .union() method.
The intersection contains elements present in both sets, using the ampersand & operator
or .intersection(). The difference contains elements in the first set that are not in the second,
2
CHRIST (Deemed to be University) Online Degree Programmes
using the minus - operator or .difference(). The symmetric difference contains elements in
either set but not both, using the caret ^ operator or .symmetric_difference().
Two other useful set methods are .copy() and .clear(). The copy() method creates a shallow
copy of a set so that changes to one don’t affect the other. The clear() method removes all
elements from a set, leaving it empty useful when you want to reuse the set variable but reset
its contents.
You can compare sets using operators. The equality operator == checks if two sets have
exactly the same elements, regardless of order. The subset operator <= checks if all elements
of one set are in another. The superset operator >= checks if one set contains all the elements
of another.
Sets have practical applications too. A common one is removing duplicates from a list. If you
convert a list with repeated elements to a set, the duplicates are automatically discarded. Sets
are also efficient for membership checks using the in operator, which is much faster than
checking in a list.
Let’s apply these concepts to a small project managing student enrollments across two
different courses. Each course’s student names are stored in sets, which avoids duplicates
automatically. First, we add a new student, Farhan, to both courses. Then, we remove a
student, Bhavna, from one course using discard() to avoid errors. We check if a specific
student, Charan, is enrolled in both courses by using membership tests. Finally, we find
which students are enrolled only in Course A and not in Course B a classic set difference
operation. This makes it easy to see exclusive enrollments.
With these examples and applications, it’s clear that sets play a crucial role in Python
programming and data science. They are fundamental for removing duplicates, performing
fast membership tests, and working with unique data. Their efficiency and versatility make
them a key data structure for any data-driven project.
Thank you for your attention! Keep experimenting with sets, and remember to use their
powerful capabilities for handling and processing your data. Keep practicing and exploring
all that sets can offer.

V5
Hello everyone, and welcome to this module on Object-Oriented Programming. In this
session, we will understand a powerful and widely used approach to software development
Object-Oriented Programming. We will explore its core concepts and see how it helps us
build more organized and maintainable software.
Before diving into Object-Oriented Programming, let us briefly touch upon procedural
programming, which you might be familiar with. In this approach, we write a series of
instructions, much like following a recipe. Data, such as the ingredients in our recipe, and the
functions or procedures that operate on that data are treated as distinct and separate entities.
Consider the simple process of making tea. In a procedural mindset, we have a sequence of
steps: first, we boil water. Then, we add tea leaves. Next, we pour the tea into a cup. After
that, we might add milk, and finally, we add sugar. Here, the water, tea leaves, milk, and
sugar are our data, and actions like “boil,” “add,” and “pour” are the procedures acting on
them.
Now, imagine if we wanted to make iced tea instead. We would likely need a completely
different set of procedures: boil water, steep tea, cool the tea, add ice, maybe add lemon.
While some of the ingredients are the same, the steps and the order are different. This
illustrates a key limitation of procedural programming: when we want to manipulate our data
in a new way, we often need to create entirely new sets of instructions. As software projects
grow in size and complexity, this separation can lead to code that becomes difficult to
manage, modify, and maintain.
Object-Oriented Programming represents a shift in how we approach software design. It
emphasises the creation of modular, self-contained entities known as objects, and defines
how these objects interact with one another. These ideas form the base for all other OOP
concepts. By embracing these principles, OOP offers significant advantages, particularly
when tackling large, complex projects.
It allows us to reuse code effectively through mechanisms like inheritance, achieve a logical
and intuitive organization of the codebase, and enhance maintainability by making it easier to
modify and extend without disrupting other parts of the system. The five key ideas to
understand are: Objects, which serve as the building blocks representing real-world or
conceptual entities; Encapsulation, the principle of bundling data and methods into a single
unit; Abstraction, which hides complex internal workings while exposing only essential
information; Inheritance, which enables creating new objects from existing ones for
reusability and hierarchy; and Polymorphism, which allows different types of objects to
respond uniquely to the same method call.
2
CHRIST (Deemed to be University) Online Degree Programmes
Instead of treating data and functions as separate entities, OOP centers around the concept of
objects self-contained units that bundle together data (attributes or properties) and actions
(methods or behaviours). These objects come from blueprints called classes. A class defines
what attributes any object of that type will have and what methods it can perform.
For example, consider a “Car.” The Car class might define attributes such as colour, model,
and current speed, and methods such as start(), accelerate(), and brake(). The Car class is the
blueprint, while individual cars like a red Toyota Camry or a blue Honda Civic are objects
or instances of the class. They share the actions and attributes defined in the class but have
their own specific attribute values. One car object might be red, another blue; one might have
a current speed of 0, another 60. This idea of classes as templates, and objects as individual
entities with their own data but shared actions, is central to OOP.
One of OOP’s fundamental principles is encapsulation. Imagine a capsule containing
medicine: the various compounds inside (representing an object’s data and inner workings)
are enclosed in the capsule shell. You, as the patient, don’t access the chemicals directly; you
interact with the capsule as a whole. Encapsulation means bundling together an object’s
attributes and methods within a single unit. It hides internal implementation details from the
outside world, so other parts of the program interact with objects only through their public
methods.
For instance, with a Car object, you don’t directly set the engine’s internal variables; you use
methods like accelerate(), which controls how the internal speed attribute changes. This
protects the object’s data from unintended changes, makes the code more robust, and makes
the system easier to maintain.
Working alongside encapsulation is abstraction. While encapsulation controls access to an
object’s data, abstraction focuses on what an object does rather than how it does it. It
simplifies the view of an object by showing only essential features and hiding the complex
implementation.
Think of a TV remote. You know that pressing the power button turns the TV on or off, and
pressing channel up changes the channel. You don’t need to know the details of the electronic
signals or protocols involved. Similarly, in OOP, abstraction hides the internal complexity of
methods. With our Car example, calling accelerate() might involve complex calculations, but
you don’t need to know them you just know it increases the car’s speed. This makes working
with objects simpler and allows internal logic to change without affecting outside code that
uses the object.
Inheritance is another core concept in OOP. It lets us create a new class based on an existing
one. For example, if we have a Car class with attributes and methods, we could create a
SportsCar class that automatically inherits these features. SportsCar can then add new
attributes like spoiler or methods like engageTurboBoost(), and it can also override inherited
methods to behave differently like accelerating faster than a regular car. Inheritance
promotes code reuse and naturally creates a hierarchy of classes, such as Car → SportsCar,
Sedan, SUV, each with its own unique features.
Polymorphism, meaning “many forms,” allows one interface to be used for different
underlying forms. In real life, the “speak” action differs by animal a dog barks, a cat meows,
a human talks. Similarly, in OOP, a parent class might define a method like makeSound(),
and subclasses each implement it differently. This means you can write general code that
calls makeSound() without worrying about the specific object type each object will respond
3
CHRIST (Deemed to be University) Online Degree Programmes
appropriately. Polymorphism makes programs more flexible and easier to extend with new
object types without changing existing code.
OOP has several key advantages. Modularity objects act as self-contained units, making
code organised and easier to understand. Reusability inheritance allows building on existing
code, saving effort. Maintainability encapsulation makes it safer to modify a specific
component without impacting others. Scalability breaking down large problems into smaller
objects with clear interfaces makes systems easier to grow and adapt. Real-world
modelling thinking in terms of objects with attributes and behaviours lets us mirror realworld situations in our code in a more intuitive way.
In conclusion, Object-Oriented Programming provides a powerful, intuitive approach to
structuring software. By using concepts like objects, encapsulation, abstraction, inheritance,
and polymorphism, we can create code that is organised, reusable, and maintainable. These
fundamentals underpin many of today’s programming tools and frameworks, making them
essential knowledge for any developer.
In the upcoming session, we will move from theory to practice, learning how to define
classes in Python and create and interact with objects. Thank you for your time and attention,
and I look forward to exploring the practical application of these concepts with you in the
next video.
